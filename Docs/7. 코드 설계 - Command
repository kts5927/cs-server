7. 코드설계 - Command

Q. 왜 OOP로 코드를 구성하였는지?

Command를 설계할때 2가지 방식 중 고민을 하였습니다.

    - 전역 Static을 활용한 메서드화
    - OOP를 활용한 싱글톤

전역 Static을 활용하게 되면 얻는 장점은 분명히 있습니다.
인스턴스를 만들지 않으니 Heap메모리를 사용하지 않고, 
선언 후 호출만 하면 되니 사용하기도 편리합니다.
하지만 만약 Command를 확장할때, 상속/인터페이스 구현이 불가능합니다.
따라서 현재로서는 좋은 방법이라고 생각하지만, 코드의 확장을 생각하면 OOP가 좋아보이며
코드가 적은 서버이기에 OOP를 활용하기 위한 오버헤드를 충분히 감수할 수 있습니다.

이뿐만 아니라 OOP를 활용한 싱글톤 방식은 또다른 장점이 있습니다.
그것은 바로 CommandTable에 있습니다.
상황에 따라 만들어놓은 명령어를 사용해야 될 때도, 막아야 할 때도 있습니다.
만약 버그가 발생해서 특정 Command를 사용하지 못하게 해야 할 때, 

    - Static 메서드화 코드는 특정 기능을 하는 메서드 전체를 주석처리 해야 합니다.
    - 현재 코드는 CommandTable에서 원하는 코드만을 주석처리 하면 됩니다.

만약 Static 메서드화 코드의 경우, 주석처리를 미처 다 하지 못한 경우
다른 곳에서 버그가 발생할 수도 있으며, 추후 디버깅 후 코드를 복구하는데에도
추가적인 생각이 필요하고 병합성 문제를 해결해야 합니다.

하지만 단순히 CommandTable에서 특정 Command만을 주석 처리한 경우, 
단위 테스트의 경우 코드의 추가/제거가 간편해서 훨씬 빠르고 정확하게 테스트가 가능하고, 
특정 Command에 문제가 발생하면 그 한줄만을 주석처리 하면 되기 때문에
문제에 대한 대처 또한 빠르고, 정확해 집니다.


Q. 다른 이유는 없는지?

A. CommandRegistry를 활용한 Command 자동등록에 있습니다.

현재 채팅 서버에 들어오는 메시지는 다음과 같이 구성되어 있습니다.

    - Header / Type (/all, /whisper, /join 등)
    - Body / Payload (메시지)

유저의 메시지를 핸들링 할때, Packet을 파싱한 후 다양한 분기를 통해서 함수에 진입하는 것이 아닌, 
Execute(Session, Packet) 함수를 통해 자동으로 해당 Command가 실행됩니다.

out var func 코드를 통해, Type에 알맞는 Command가 실행되고,
이를 위해서 해야할 일은
CommandTable에 작성한 Command를 추가하면 됩니다.

CommandRegistry.Register가 명령어 자동 추가 역할을 수행하고, 
서버가 실행된 직후 다음의 흐름을 따라 실행됩니다.

    - Program.cs : ChatServerHost();
    - ChatServerHost.cs : CommandTable.RegisterAll();

따라서, 유저는 작성한 코드를 CommandTable에 추가함으로써
쉽고 간편하게 명령어를 추가할 수 있게 되는 것입니다.
이러한 코드 구조는 서버 내의 자동화 파이프라인 기능을 수행하며, 
서버를 확장할때 큰 도움이 됩니다.